//SOLID

// 1- S primeira letra é o S, de Single responsibility principle, princípio da responsabilidade única. O que isso significa? Significa que cada módulo, cada classe, cada método, só tem que ter um motivo para mudar, para sofrer alterações, para executar código.

// Podemos melhorar essa explicação da seguinte forma, digamos que o módulo é responsável por uma, e somente uma entidade. Chama ator ou entidade do nosso projeto. No caso, um usuário é uma entidade no nosso projeto. E tem que fazer coisas relativas apenas a essa entidade. Muita gente confunde essa responsabilidade única como fazer só uma tarefa, não precisa necessariamente ser isso. Uma classe tem que tratar somente de users. E os métodos internos dela, quando começamos a trabalhar com funções, nós aprendemos, os métodos internos fazem coisas muito específicas, tarefas específicas.

//Mas uma classe é responsável por uma entidade e os métodos internos dela são responsáveis por uma tarefa. Então, cada parte do código, cada módulo ela faz uma coisa só, ela só tem uma responsabilidade.

// 2-  o O, de SOLID, significa open/closed principle, ou seja, o princípio do aberto/fechado. É um nome meio esquisito, mas aberto e fechado nesse caso, significa que a classe tem que estar aberta para ser expandida, porém fechada, para ser modificada. Ou seja, a ideia nesse caso, é que seja possível adicionar funcionalidades em uma classe, mas não alterar métodos de uma classe que já existem e que já estão em funcionamento ou alterar essas classes mesmo.

//Então, por exemplo, supondo que a classe user tem que retornar os dados de um usuário de uma forma diferente, porque tem uma funcionalidade nova que precisa fazer um relatório. Então, não modificamos o método exibirInfos, que já existe, adicionamos um novo método para atender essa nova demanda. Então, por exemplo, um método exibirRelatorio, que vai mandar as informações para fora, do jeito que a funcionalidade nova está pedindo.

// 3- o terceiro princípio é o L, de Liskov substitution principle, o princípio da substituição de Liskov. Liskov é Barbara Liskov, uma cientista da computação, que foi quem pensou, quem primeiro formalizou isso que chamamos de princípio de substituição. Então, é porque o princípio é dela, e não porque a Barbara Liskov vai ser substituída.

// Então, isso significa que, se temos uma subclasse e uma superclasse, ou seja, uma classe que herda da outra, deveria ser possível sempre substituir uma pela outra, sem que nada deixe de funcionar. Como assim? Em outras palavras, se uma classe tem um atributo, a subclasse dela também tem que ter. Se algo funciona na superclasse, tem que funcionar na subclasse também. Ou seja, uma subclasse não pode fazer o que chamamos de quebrar contratos feitos pela superclasse. Ou seja, uma coisa que está estabelecida pela superclasse, não pode ser quebrada pela subclasse.

// 4-  O I de SOLID é interface segregation principle, que é o princípio de segregação de interface. Então, esse princípio diz que clientes não devem ser forçados a depender de interfaces que eles não usam. Vamos dar uma explicada, sem utilizar interfaces. Basicamente, esse princípio diz que não podemos impor uma implementação de uma coisa que não vai ser necessária. Por exemplo, eu, Daniel, sou vegetariana, então minha classe Daniel não utilizaria métodos, por exemplo, que envolvam carne, todos os métodos que envolvem carne na classe Daniel são desnecessários.

//Então, não podemos impor que a minha classe Daniel tenha um método que não vai usar. Como o JavaScript, novamente, não tem interfaces, esse princípio não tem como ser aplicado diretamente usando JavaScript, porque as interfaces estabelecem contratos, ou seja, elas estabelecem o que deve ser implementado toda vez que instanciamos uma classe. E não ter isso no JavaScript, não termos esse comportamento de implementação forçada, digamos assim. Vou deixar, novamente, o material extra, para você conferir o que são as interfaces, e esse princípio vai fazer um pouco mais de sentido.

// 5-  E o último, o D, é o dependency inversion principle, que é o princípio da inversão de dependência. Ou seja, digamos que módulos que estão em um nível mais acima da hierarquia de classes, não podem depender de nada que está abaixo deles, e também diz que nenhum deles podem depender de implementações, e sim, de abstrações. Como explicamos isso?

// Quando falamos de abstração, estamos falando de esconder detalhes de como uma coisa funciona. Então, usamos um computador, utilizamos as interfaces do computador mesmo, o teclado é uma interface do computador, então a interface entre o computador e o ser humano, todas as entradas USB são interfaces por onde nos comunicamos com o computador, mas não vemos por dentro o funcionamento dele, o funcionamento dele, interno, teoricamente, não para nós que estudamos e trabalhamos na área, mas para o usuário do computador, a implementação interna do computador, como ele funciona por dentro, não é uma coisa que ele precisa saber, uma coisa que interessa.

//Vamos usar como exemplo a classe user. Então supondo que tenhamos dados de user, suponde que estamos usando algum banco de dados para guardar esses dados, e esses dados precisam ser salvos em algum lugar, em algum tipo de banco. E podemos criar um método salvarDados, que vai ser chamado na hora de salvar esses dados, e dentro dele, criamos uma instância de uma classe chamada const db = new ConcexaoSQL, e a partir dessa instância de conexão SQL, dessa nova conexão que criamos, salvando na variável DB, faz toda a lógica de salvar os dados do usuário no banco.

//Com isso, nós fechamos essa apresentação aos princípios do SOLID, tem N materiais sobre SOLID, tem material didático, tem vídeo, tem tese, tem trabalho de faculdade feito sobre isso, um tema vasto, o que demos é só uma introdução, e agora com esse conteúdo fechamos nossos primeiros passos em orientação a objetos com JavaScript.
